<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Dockerfiles</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Dockerfiles</h1><br/>             Dockerfiles play an  essential role in Docker. Dockerfiles is a formatted text file which  essentially serves as an instruction manual for what containers should  do and ultimately assembles a Docker image.<br />You use Dockerfiles to  contain the commands the container should execute when it is built. To  get started with Dockerfiles, we need to know some basic syntax and  instructions. Dockerfiles are formatted in the following way:<br /><code>INSTRUCTION argument</code><br />First, let’s cover some essential instructions:<br /><table class="table"><tr><th>Instruction</th><th>Description</th><th>Example</th></tr><tr><td>FROM</td><td>This instruction sets a build stage for the container as well as setting the base image (operating system). All Dockerfiles must start with this.</td><td>FROM ubuntu</td></tr><tr><td>RUN</td><td>This instruction will execute commands in the container within a new layer.</td><td>RUN whoami</td></tr><tr><td>COPY</td><td>This instruction copies files from the local system to the working directory in the container (the syntax is similar to the cp command).</td><td>COPY /home/cmnatic/myfolder/app/</td></tr><tr><td>WORKDIR</td><td>This instruction sets the working directory of the container. (similar to using cd on Linux).</td><td>WORKDIR /
(sets to the root of the filesystem in the container)</td></tr><tr><td>CMD</td><td>This instruction determines what command is run when the container starts (you would use this to start a service or application).</td><td>CMD /bin/sh -c script.sh</td></tr><tr><td>EXPOSE</td><td>This instruction is used to tell the person who runs the container what port they should publish when running the container.</td><td>EXPOSE 80
(tells the person running the container to publish to port 80 i.e. docker run -p 80:80)</td></tr></table><br />Now  that we understand the core instructions that make up a Dockerfile,  let’s see a working example of a Dockerfile. But first, I’ll explain  what I want the container to do:<br /><br />1. Use the “Ubuntu” (version 22.04) operating system as the base.<br />2. <small>Set the working directory to be the root of the container.</small><br />3. Create the text file “helloworld.txt”.<br /><code># THIS IS A COMMENT<br /># Use Ubuntu 22.04 as the base operating system of the container<br />FROM ubuntu:22.04<br /><br /># Set the working directory to the root of the container<br />WORKDIR / <br /><br /># Create helloworld.txt<br />RUN touch helloworld.txt</code>Remember, the commands that you can run via the <code>RUN</code> instruction will depend on the operating system you use in the <code>FROM</code> instruction.  (In this example, I have chosen Ubuntu. It’s important to remember that  the operating systems used in containers are usually very minimal.  I.e., don’t expect a command to be there from the start (even commands  like <em>curl</em>, <em>ping</em>, etc., may need to be installed.)<br /><h2>Building Your First Container</h2><br /><br /><small>Once we have a Dockerfile, we can create an image using the </small><code>docker build</code><small> command. This command requires a few pieces of information:</small><br />1. Whether or not you want to name the image yourself (we will use the <code>-t</code> (tag) argument).<br />2. The name that you are going to give the image.<br />3. The location of the Dockerfile you wish to build with.<br />I’ll provide the scenario and then explain the relevant command. Let’s say we want to build an image - let’s fill in the two required pieces of information listed above:<br />1. We are going to name it ourselves, so we are going to use the <code>-t</code> argument.<br />2. We want to name the image.<br />3. The Dockerfile is located in our current working directory (<code>.</code>).<br />The Dockerfile we are going to build is the following:<br /><br /><code># Use Ubuntu 22.04 as the base operating system of the container<br />FROM ubuntu:22.04<br /><br /># Set the working directory to the root of the container<br />WORKDIR / <br /><br /># Create helloworld.txt<br />RUN touch helloworld.txt</code>The command would look like so: <code>docker build -t helloworld .</code> (we are using the dot to tell Docker to look in our working directory). If we have filled out the command right, we will see Docker starting to build the image:            A terminal showing the building process of the &quot;helloworld&quot; image<br /><br />                   <code>cmnatic@thm:~$ docker build -t helloworld .<br />Sending build context to Docker daemon  4.778MB<br />Step 1/3 : FROM ubuntu:22.04<br />22.04: Pulling from library/ubuntu<br />2b55860d4c66: Pull complete<br />Digest: sha256:20fa2d7bb4de7723f542be5923b06c4d704370f0390e4ae9e1c833c8785644c1<br />Status: Downloaded newer image for ubuntu:22.04<br /> ---&gt; 2dc39ba059dc<br />Step 2/3 : WORKDIR /<br /> ---&gt; Running in 64d497097f8a<br />Removing intermediate container 64d497097f8a<br /> ---&gt; d6bd1253fd4e<br />Step 3/3 : RUN touch helloworld.txt<br /> ---&gt; Running in 54e94c9774be<br />Removing intermediate container 54e94c9774be<br /> ---&gt; 4b11fc80fdd5<br />Successfully built 4b11fc80fdd5<br />Successfully tagged helloworld:latest<br />cmnatic@thm:~$</code><br />            <br /><br /><br />Great! That looks like a success. Let’s use <code>docker image ls</code> to now see if this image has been built:<br />            Using the &quot;docker image ls&quot; command to confirm whether or not our image has successfully built<br />                   <code>cmnatic@thm:~$ docker image ls<br />REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br />helloworld   latest    4b11fc80fdd5   2 minutes ago   77.8MB<br />ubuntu       22.04     2dc39ba059dc   10 days ago     77.8MB<br />cmnatic@thm:~$</code><br />            <br /><br />Note: Whatever base operating system you list in the <code>FROM</code> instruction in the Dockerfile will also be downloaded. This is why we can see two images:<br />1. helloworld (our image).<br />2. ubuntu (the base operating system used in our image).<br />You  will now be able to use this image in a container. Refer to the  “Running Your First Container” task to remind you how to start a  container.<br /><h2>Levelling up Our Dockerfile</h2><br /><br />Let’s level up our Dockerfile. So far, our container will only create a file - that’s not very useful! In the following Dockerfile, I am going to:<br />1. Use Ubuntu 22.04 as the base operating system for the container.<br />2. Install the “apache2” web server.<br />3. Add some networking. As this is a web server, we will need to be able to connect to the container over the network somehow. I will achieve this by using the <code>EXPOSE</code> instruction and telling the container to expose port <em>80</em>.<br />4. Tell the container to start the “apache2” service at startup. Containers do not have service managers like <code>systemd</code> (this is by design - it is bad practice to run multiple applications in the same container. For example, this container is for the apache2 web server - and the apache2 web server only).<br /><code># THIS IS A COMMENT<br />FROM ubuntu:22.04<br /><br /># Update the APT repository to ensure we get the latest version of apache2<br />RUN apt-get update -y <br /><br /># Install apache2<br />RUN apt-get install apache2 -y<br /><br /># Tell the container to expose port 80 to allow us to connect to the web server<br />EXPOSE 80 <br /><br /># Tell the container to run the apache2 service<br />CMD [&quot;apache2ctl&quot;, &quot;-D&quot;,&quot;FOREGROUND&quot;]</code><br />For reference, the command to build this would be <code>docker build -t webserver .</code>  (assuming the Dockerfile is in the same directory as where you run the  command from). Once starting the container with the appropriate options (<code>docker run -d --name webserver -p 80:80  webserver</code>), we can navigate to the IP address of our local machine in our browser!<br /><a href="https://tryhackme-images.s3.amazonaws.com/user-uploads/5de96d9ca744773ea7ef8c00/room-content/95f7f4b43b7cdf6079a71a7a3e19f937.png"><img src="images/82-1.png" alt="images/82-1.png" /></a><br /><br /><br />The web server works! Currently, Apache2 is serving the default files because we have not added our own to the container.<br /><h2>Optimising Our Dockerfile</h2><br />There’s  certainly an art to Docker - and it doesn’t stop with Dockerfiles!  Firstly, we need to ask ourselves why is it essential to optimise our  Dockerfile? Bloated Dockerfiles are hard to read and maintain and often  use a lot of unnecessary storage! For example, you can reduce the size  of a docker image (and reduce build time!) using a few ways:<br />1. Only installing the essential packages. What’s nice about containers is that they’re practically empty from the get-go - we have complete freedom to decide what we want.<br />2. Removing cached files (such as APT  cache or documentation installed with tools). The code within a  container will only be executed once (on build!), so we don’t need to  store anything for later use.<br />3. Using minimal base operating systems in our <code>FROM</code> instruction. Even though operating systems for containers such as Ubuntu are already pretty slim, consider using an even more stripped-down version (i.e. <code>ubuntu:22.04-minimal</code>). Or, for example, using Alpine (which can be as small as 5.59MB!).<br />4. Minimising the number of layers - I’ll explain this further below.<br />Each instruction (I.E. <code>FROM</code>, <code>RUN</code>,  etc.) is run in its own layer. Layers increase build time! The  objective is to have as few layers as possible. For example, try  chaining commands from <code>RUN</code> together like so:<br /><strong>Before:</strong><br /><code>FROM ubuntu:latest<br />RUN apt-get update -y<br />RUN apt-get upgrade -y<br />RUN apt-get install apache2 -y<br />RUN apt-get install net-tools -y</code>            A terminal showing five layers of a Dockerfile being built<br /><br />                   <code>cmnatic@thm:~$ docker build -t before .<br />--omitted for brevity--<br />Step 2/5 : RUN apt-get update -y<br /> ---&gt; Using cache<br /> ---&gt; 446962612d20<br />Step 3/5 : RUN apt-get upgrade -y<br /> ---&gt; Running in 8bed81c695f4<br />--omitted for brevity--<br />cmnatic@thm:~$</code><br />        <br /><br /><br /><strong>After:</strong><br /><code>FROM ubuntu:latest<br />RUN apt-get update -y &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install apache2 -y &amp;&amp; apt-get install net-tools</code>                        A terminal showing two layers of a Dockerfile being built<br />                   <code>cmnatic@thm:~$ docker build -t after .<br />Sending build context to Docker daemon   4.78MB<br />Step 1/2 : FROM ubuntu<br /> ---&gt; 2dc39ba059dc<br />Step 2/2 : RUN apt-get update -y &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install apache2 -y &amp;&amp; apt-get install net-tools<br /> ---&gt; Running in a4d4943bcf04<br />--omitted for brevity--<br />cmnatic@thm:~$</code><br />        <br /><br /><a href="https://tryhackme-images.s3.amazonaws.com/user-uploads/5de96d9ca744773ea7ef8c00/room-content/743dd22bcf1f3a709ee6288d519d5930.png"><img src="images/82-2.png" alt="images/82-2.png" /></a><br /><br />Note  here how there are now only two build steps (this will be two layers,  making the build much quicker). This is just a tiny example of a  Dockerfile, so the build time will not be so drastic, but in much larger  Dockerfiles - reducing the number of layers will have a fantastic  performance increase during the build.<br /><br />        <br />                            <br /><br /></div></body></html>